# üìã Audit des Fonctionnalit√©s de Facturation - SmartQueue

**Date**: 14 octobre 2025
**Statut**: Audit complet des fonctionnalit√©s avanc√©es de facturation

---

## üîç Vue d'Ensemble

Cet audit v√©rifie l'impl√©mentation de 6 fonctionnalit√©s avanc√©es de facturation recommand√©es pour un SaaS moderne.

---

## ‚úÖ Fonctionnalit√©s Existantes (Impl√©ment√©es)

### 1. **Base de Facturation** ‚úì
- ‚úÖ Mod√®le `Invoice` complet avec statuts
- ‚úÖ Mod√®le `Transaction` pour historique
- ‚úÖ Mod√®le `PaymentMethod` avec support Mobile Money (7 providers)
- ‚úÖ Mod√®le `Subscription` avec billing cycles
- ‚úÖ Mod√®le `SubscriptionPlan` avec tarification
- ‚úÖ G√©n√©ration PDF professionnelle (ReportLab)
- ‚úÖ API RESTful compl√®te (6 endpoints)

### 2. **Pages Frontend** ‚úì
- ‚úÖ Dashboard Transactions
- ‚úÖ Analytics MRR/ARR avec m√©triques SaaS
- ‚úÖ Gestion des impay√©s (Dunning basic)
- ‚úÖ Menu de navigation avec sous-menu

---

## ‚ùå Fonctionnalit√©s Manquantes (√Ä Impl√©menter)

### 1. ‚ùå **Codes Promo et R√©ductions**

**Statut**: **NON IMPL√âMENT√â**

**Ce qui manque**:
- Aucun mod√®le `Coupon` ou `Discount`
- Pas de syst√®me de codes promotionnels
- Pas d'application automatique de r√©ductions
- Pas de validation de codes promo
- Pas de limites d'utilisation

**Mod√®le n√©cessaire**:
```python
class Coupon(TimeStampedModel):
    code = models.CharField(max_length=50, unique=True)
    discount_type = models.CharField(...)  # percentage, fixed_amount
    discount_value = models.DecimalField(...)
    valid_from = models.DateTimeField()
    valid_to = models.DateTimeField()
    max_uses = models.IntegerField()
    current_uses = models.IntegerField(default=0)
    is_active = models.BooleanField(default=True)
    applicable_plans = models.ManyToManyField(SubscriptionPlan)
    # Pour qui: tous, nouveaux clients, existants
    customer_eligibility = models.CharField(...)
```

**Impact**: üî¥ **HAUTE PRIORIT√â** - Essentiel pour marketing et acquisition

---

### 2. ‚ùå **Facturation Bas√©e sur l'Usage (Usage-Based Billing)**

**Statut**: **NON IMPL√âMENT√â**

**Ce qui manque**:
- Aucun syst√®me de m√©triques d'usage
- Pas de compteur de consommation
- Pas de tarification variable
- Pas de seuils et d'overages
- Pas d'agr√©gation d'usage mensuel

**Mod√®les n√©cessaires**:
```python
class UsageMetric(TimeStampedModel):
    """D√©finition d'une m√©trique facturable"""
    name = models.CharField()  # ex: "tickets_created"
    unit_name = models.CharField()  # ex: "ticket"
    unit_price = models.DecimalField()
    billing_scheme = models.CharField()  # per_unit, tiered, volume

class UsageRecord(TimeStampedModel):
    """Enregistrement d'usage"""
    tenant = models.ForeignKey(Tenant)
    metric = models.ForeignKey(UsageMetric)
    quantity = models.IntegerField()
    timestamp = models.DateTimeField()
    metadata = models.JSONField()

class UsageSummary(TimeStampedModel):
    """Agr√©gation mensuelle"""
    tenant = models.ForeignKey(Tenant)
    metric = models.ForeignKey(UsageMetric)
    period_start = models.DateField()
    period_end = models.DateField()
    total_quantity = models.IntegerField()
    total_amount = models.DecimalField()
```

**Exemples d'usage**:
- Tickets cr√©√©s au-del√† du plan
- SMS/Emails envoy√©s
- Utilisateurs actifs
- Stockage utilis√©

**Impact**: üü° **MOYENNE PRIORIT√â** - Important pour scalabilit√©

---

### 3. ‚ùå **Portail Self-Service Client**

**Statut**: **NON IMPL√âMENT√â**

**Ce qui manque**:
- Aucune interface client d√©di√©e
- Pas de gestion d'abonnement par le client
- Pas de t√©l√©chargement de factures
- Pas de mise √† jour de carte bancaire
- Pas d'historique de paiements accessible

**Pages n√©cessaires**:
1. **Dashboard Client** (`/portal/dashboard`)
   - R√©sum√© abonnement actuel
   - Prochaine facturation
   - Consommation actuelle

2. **Facturation** (`/portal/billing`)
   - Historique des factures
   - T√©l√©chargement PDF
   - √âtat des paiements

3. **Abonnement** (`/portal/subscription`)
   - Plan actuel
   - Upgrade/Downgrade
   - Annulation

4. **M√©thodes de Paiement** (`/portal/payment-methods`)
   - Ajouter/Modifier carte
   - D√©finir m√©thode par d√©faut

**Endpoints API n√©cessaires**:
```
GET    /api/v1/portal/subscription
PUT    /api/v1/portal/subscription/upgrade
PUT    /api/v1/portal/subscription/downgrade
DELETE /api/v1/portal/subscription/cancel

GET    /api/v1/portal/invoices
GET    /api/v1/portal/invoices/{id}/download

GET    /api/v1/portal/payment-methods
POST   /api/v1/portal/payment-methods
DELETE /api/v1/portal/payment-methods/{id}
```

**Impact**: üî¥ **HAUTE PRIORIT√â** - Critique pour satisfaction client

---

### 4. ‚ùå **Syst√®me de Relances Automatiques (Dunning Automation)**

**Statut**: **PARTIELLEMENT IMPL√âMENT√â**

**Ce qui existe**:
- ‚úÖ Page frontend d'impay√©s avec scoring de risque
- ‚úÖ Actions manuelles (rappel, plan, suspension)

**Ce qui manque**:
- ‚ùå T√¢ches Celery automatiques
- ‚ùå Envoi automatique de rappels
- ‚ùå Escalade automatique des impay√©s
- ‚ùå Suspension automatique apr√®s X jours
- ‚ùå Retry de paiement automatique
- ‚ùå Notifications SMS/Email configurables

**Tasks Celery n√©cessaires**:
```python
# apps/tenants/tasks.py

@shared_task
def check_overdue_invoices():
    """V√©rifie les factures impay√©es et lance les actions"""
    overdue = Invoice.objects.filter(
        status='open',
        due_date__lt=timezone.now()
    )
    for invoice in overdue:
        days_overdue = (timezone.now().date() - invoice.due_date).days

        if days_overdue == 3:
            send_first_reminder(invoice)
        elif days_overdue == 7:
            send_second_reminder(invoice)
        elif days_overdue == 15:
            send_warning_notice(invoice)
        elif days_overdue == 30:
            suspend_service(invoice.tenant)

@shared_task
def retry_failed_payments():
    """Retente les paiements √©chou√©s"""
    ...

@shared_task
def generate_recurring_invoices():
    """G√©n√®re les factures r√©currentes mensuelles/annuelles"""
    ...
```

**Configuration Celery Beat n√©cessaire**:
```python
# settings/base.py
CELERY_BEAT_SCHEDULE = {
    'check-overdue-invoices': {
        'task': 'apps.tenants.tasks.check_overdue_invoices',
        'schedule': crontab(hour=9, minute=0),  # Tous les jours √† 9h
    },
    'retry-failed-payments': {
        'task': 'apps.tenants.tasks.retry_failed_payments',
        'schedule': crontab(hour=2, minute=0),  # Tous les jours √† 2h
    },
    'generate-recurring-invoices': {
        'task': 'apps.tenants.tasks.generate_recurring_invoices',
        'schedule': crontab(hour=0, minute=0, day_of_month=1),  # 1er de chaque mois
    },
}
```

**Impact**: üî¥ **HAUTE PRIORIT√â** - Critique pour automatisation

---

### 5. ‚ùå **Notes de Cr√©dit (Avoir / Credit Notes)**

**Statut**: **NON IMPL√âMENT√â**

**Ce qui manque**:
- Aucun mod√®le `CreditNote`
- Pas de syst√®me de remboursement partiel
- Pas d'ajustement de facture
- Pas de contre-passation
- Pas de gestion des avoirs

**Mod√®le n√©cessaire**:
```python
class CreditNote(TimeStampedModel):
    """Note de cr√©dit (Avoir) pour remboursement ou ajustement"""

    credit_note_number = models.CharField(max_length=100, unique=True)
    tenant = models.ForeignKey(Tenant, on_delete=models.CASCADE)
    invoice = models.ForeignKey(Invoice, on_delete=models.CASCADE)

    # Montants
    subtotal = models.DecimalField()
    tax = models.DecimalField()
    total = models.DecimalField()
    currency = models.CharField(max_length=3, default='XOF')

    # Type
    REASON_REFUND = 'refund'
    REASON_ADJUSTMENT = 'adjustment'
    REASON_DISCOUNT = 'discount'
    REASON_ERROR = 'error'

    REASON_CHOICES = [
        (REASON_REFUND, 'Remboursement'),
        (REASON_ADJUSTMENT, 'Ajustement'),
        (REASON_DISCOUNT, 'R√©duction'),
        (REASON_ERROR, 'Erreur de facturation'),
    ]

    reason = models.CharField(max_length=20, choices=REASON_CHOICES)
    description = models.TextField()

    # Statut
    STATUS_DRAFT = 'draft'
    STATUS_ISSUED = 'issued'
    STATUS_APPLIED = 'applied'
    STATUS_VOID = 'void'

    status = models.CharField(...)

    # Dates
    issue_date = models.DateField()
    applied_at = models.DateTimeField(null=True, blank=True)

    # PDF
    pdf_url = models.URLField(blank=True)
```

**Cas d'usage**:
- Remboursement client m√©content
- Erreur de facturation
- Ajustement de prix r√©troactif
- Compensation pour service interrompu
- Cr√©dit promotionnel

**Impact**: üü° **MOYENNE PRIORIT√â** - Important pour conformit√© comptable

---

### 6. ‚ùå **Plans de Paiement √âchelonn√©s**

**Statut**: **NON IMPL√âMENT√â**

**Ce qui manque**:
- Aucun syst√®me d'√©ch√©ancier
- Pas de paiement en plusieurs fois
- Pas de planification de paiements
- Pas de relance par √©ch√©ance
- Pas de gestion des paiements partiels

**Mod√®les n√©cessaires**:
```python
class PaymentPlan(TimeStampedModel):
    """Plan de paiement √©chelonn√© pour une facture"""

    tenant = models.ForeignKey(Tenant)
    invoice = models.ForeignKey(Invoice)

    # Configuration
    total_amount = models.DecimalField()
    number_of_installments = models.IntegerField()
    frequency = models.CharField()  # weekly, monthly
    start_date = models.DateField()

    # Statut
    STATUS_ACTIVE = 'active'
    STATUS_COMPLETED = 'completed'
    STATUS_DEFAULTED = 'defaulted'
    STATUS_CANCELLED = 'cancelled'

    status = models.CharField(...)

class PaymentInstallment(TimeStampedModel):
    """√âch√©ance individuelle d'un plan"""

    payment_plan = models.ForeignKey(PaymentPlan)
    installment_number = models.IntegerField()  # 1, 2, 3...

    # Montants
    amount = models.DecimalField()
    amount_paid = models.DecimalField(default=0)

    # Dates
    due_date = models.DateField()
    paid_at = models.DateTimeField(null=True, blank=True)

    # Statut
    STATUS_PENDING = 'pending'
    STATUS_PAID = 'paid'
    STATUS_LATE = 'late'
    STATUS_FAILED = 'failed'

    status = models.CharField(...)

    # Transaction li√©e
    transaction = models.ForeignKey(Transaction, null=True)
```

**Workflow**:
1. Client demande plan de paiement
2. Admin approuve et configure (ex: 3 fois, mensuel)
3. Syst√®me cr√©e N √©ch√©ances
4. Relances automatiques avant chaque √©ch√©ance
5. Retry automatique si √©chec
6. Alerte si retard sur une √©ch√©ance

**Impact**: üü° **MOYENNE PRIORIT√â** - Utile pour fid√©lisation

---

## üìä R√©capitulatif de l'Audit

### Tableau de Bord

| Fonctionnalit√© | Statut | Priorit√© | Effort |
|----------------|--------|----------|--------|
| **Codes Promo** | ‚ùå Non impl√©ment√© | üî¥ Haute | 3-5 jours |
| **Usage-Based Billing** | ‚ùå Non impl√©ment√© | üü° Moyenne | 5-7 jours |
| **Portail Client** | ‚ùå Non impl√©ment√© | üî¥ Haute | 7-10 jours |
| **Relances Auto** | üü° Partiellement | üî¥ Haute | 2-3 jours |
| **Notes de Cr√©dit** | ‚ùå Non impl√©ment√© | üü° Moyenne | 3-4 jours |
| **Plans √âchelonn√©s** | ‚ùå Non impl√©ment√© | üü° Moyenne | 4-5 jours |

### Statistiques

```
‚úÖ Impl√©ment√©:       1/6  (17%)
üü° Partiel:          1/6  (17%)
‚ùå Non impl√©ment√©:   4/6  (66%)

üî¥ Haute priorit√©:   3/6  (50%)
üü° Moyenne priorit√©: 3/6  (50%)

Effort total estim√©: 24-34 jours
```

---

## üéØ Recommandations de Roadmap

### Phase 1 - Imm√©diate (1-2 semaines)
**Priorit√©**: üî¥ CRITIQUE - Automatisation de base

1. **Relances Automatiques** (2-3 jours)
   - T√¢ches Celery pour impay√©s
   - Envoi automatique de rappels
   - Suspension automatique

2. **Codes Promo** (3-5 jours)
   - Mod√®le Coupon
   - Validation et application
   - Interface admin

**Livrables Phase 1**:
- Syst√®me de facturation autonome
- Marketing activ√© (codes promo)
- R√©duction co√ªts support (automatisation)

---

### Phase 2 - Court Terme (2-4 semaines)
**Priorit√©**: üî¥ HAUTE - Exp√©rience client

3. **Portail Self-Service** (7-10 jours)
   - Pages client (4 pages)
   - API endpoints (8 endpoints)
   - Gestion abonnement

4. **Notes de Cr√©dit** (3-4 jours)
   - Mod√®le CreditNote
   - G√©n√©ration PDF
   - Application automatique

**Livrables Phase 2**:
- Autonomie client maximale
- Satisfaction client am√©lior√©e
- Conformit√© comptable

---

### Phase 3 - Moyen Terme (1-2 mois)
**Priorit√©**: üü° MOYENNE - Scalabilit√©

5. **Usage-Based Billing** (5-7 jours)
   - M√©triques et compteurs
   - Facturation variable
   - Reporting usage

6. **Plans √âchelonn√©s** (4-5 jours)
   - Gestion √©ch√©ances
   - Relances par installment
   - Dashboard client

**Livrables Phase 3**:
- Mod√®le tarifaire flexible
- Adaptation √† diff√©rents business models
- Fid√©lisation am√©lior√©e

---

## üîß D√©tails d'Impl√©mentation par Fonctionnalit√©

### 1. Codes Promo - Plan d'Action

**Mod√®les √† cr√©er**:
```python
# backend/apps/tenants/models.py

class Coupon(TimeStampedModel):
    # ... (voir ci-dessus)

class CouponUsage(TimeStampedModel):
    """Historique d'utilisation des coupons"""
    coupon = models.ForeignKey(Coupon)
    tenant = models.ForeignKey(Tenant)
    invoice = models.ForeignKey(Invoice, null=True)
    subscription = models.ForeignKey(Subscription, null=True)
    discount_amount = models.DecimalField()
    used_at = models.DateTimeField(auto_now_add=True)
```

**Serializers**:
```python
# backend/apps/tenants/serializers.py
class CouponSerializer(serializers.ModelSerializer):
    ...

class ApplyCouponSerializer(serializers.Serializer):
    code = serializers.CharField()
    subscription_id = serializers.UUIDField()
```

**Endpoints**:
```
POST   /api/v1/coupons/validate/     # Valider un code
POST   /api/v1/coupons/apply/        # Appliquer √† un abonnement
GET    /api/v1/admin/coupons/        # Liste des coupons (admin)
POST   /api/v1/admin/coupons/        # Cr√©er coupon (admin)
```

**Frontend** (Admin):
- Page `/superadmin/billing/coupons`
- Formulaire cr√©ation coupon
- Liste avec statistiques d'usage
- D√©sactivation/Activation

---

### 2. Relances Automatiques - Plan d'Action

**Fichier √† cr√©er**: `backend/apps/tenants/tasks.py`

**Contenu**:
```python
from celery import shared_task
from django.utils import timezone
from datetime import timedelta

@shared_task
def check_overdue_invoices():
    """T√¢che quotidienne √† 9h"""
    from apps.tenants.models import Invoice
    from apps.notifications.tasks import send_notification

    today = timezone.now().date()
    overdue = Invoice.objects.filter(
        status='open',
        due_date__lt=today
    ).select_related('tenant')

    for invoice in overdue:
        days_overdue = (today - invoice.due_date).days

        if days_overdue == 3:
            # Premier rappel amical
            send_notification(
                tenant=invoice.tenant,
                template='invoice_reminder_day_3',
                context={'invoice': invoice}
            )

        elif days_overdue == 7:
            # Deuxi√®me rappel
            send_notification(
                tenant=invoice.tenant,
                template='invoice_reminder_day_7',
                context={'invoice': invoice}
            )

        elif days_overdue == 15:
            # Avertissement suspension
            send_notification(
                tenant=invoice.tenant,
                template='invoice_warning_day_15',
                context={'invoice': invoice}
            )

        elif days_overdue >= 30:
            # Suspension automatique
            if invoice.tenant.is_active:
                invoice.tenant.is_active = False
                invoice.tenant.suspended_at = timezone.now()
                invoice.tenant.suspension_reason = f"Facture {invoice.invoice_number} impay√©e depuis 30 jours"
                invoice.tenant.save()

                send_notification(
                    tenant=invoice.tenant,
                    template='service_suspended',
                    context={'invoice': invoice}
                )

@shared_task
def generate_recurring_invoices():
    """T√¢che mensuelle le 1er du mois √† minuit"""
    from apps.tenants.models import Subscription

    today = timezone.now().date()

    # Abonnements mensuels √† renouveler
    monthly_subs = Subscription.objects.filter(
        status='active',
        billing_cycle='monthly',
        current_period_end__lte=today
    )

    for sub in monthly_subs:
        create_invoice_for_subscription(sub)
```

**Configuration Celery**:
```python
# backend/smartqueue_backend/settings/base.py

from celery.schedules import crontab

CELERY_BEAT_SCHEDULE = {
    'check-overdue-invoices': {
        'task': 'apps.tenants.tasks.check_overdue_invoices',
        'schedule': crontab(hour=9, minute=0),
    },
    'generate-recurring-invoices': {
        'task': 'apps.tenants.tasks.generate_recurring_invoices',
        'schedule': crontab(hour=0, minute=0, day_of_month=1),
    },
}
```

---

### 3. Portail Client - Plan d'Action

**Structure des pages**:
```
/back_office/app/portal/
‚îú‚îÄ‚îÄ layout.tsx               # Layout client
‚îú‚îÄ‚îÄ dashboard/page.tsx       # Dashboard
‚îú‚îÄ‚îÄ billing/
‚îÇ   ‚îú‚îÄ‚îÄ page.tsx            # Historique factures
‚îÇ   ‚îî‚îÄ‚îÄ [id]/page.tsx       # D√©tail facture
‚îú‚îÄ‚îÄ subscription/page.tsx    # Gestion abonnement
‚îî‚îÄ‚îÄ payment-methods/page.tsx # M√©thodes de paiement
```

**Endpoints API**:
```python
# backend/apps/tenants/portal_views.py

class PortalSubscriptionViewSet(viewsets.ViewSet):
    permission_classes = [IsTenantAdmin]

    def retrieve(self, request):
        """GET /api/v1/portal/subscription"""
        ...

    def upgrade(self, request):
        """POST /api/v1/portal/subscription/upgrade"""
        ...

    def cancel(self, request):
        """POST /api/v1/portal/subscription/cancel"""
        ...

class PortalInvoiceViewSet(viewsets.ReadOnlyModelViewSet):
    permission_classes = [IsTenantAdmin]

    @action(detail=True, methods=['get'])
    def download(self, request, pk=None):
        """GET /api/v1/portal/invoices/{id}/download"""
        ...
```

---

## üìà Impact Business Attendu

### Avec Codes Promo
- ‚úÖ Augmentation acquisition: +20-30%
- ‚úÖ R√©duction CAC (Cost of Acquisition)
- ‚úÖ Possibilit√© de campagnes marketing cibl√©es

### Avec Relances Auto
- ‚úÖ R√©duction impay√©s: -40-50%
- ‚úÖ √âconomie temps support: 15-20h/semaine
- ‚úÖ Am√©lioration cash flow

### Avec Portail Client
- ‚úÖ R√©duction tickets support: -60-70%
- ‚úÖ Satisfaction client: +30-40%
- ‚úÖ Autonomie client totale

### Avec Usage-Based Billing
- ‚úÖ Flexibilit√© tarifaire maximale
- ‚úÖ Adaptation besoins clients
- ‚úÖ Potentiel revenue par client: +25-35%

---

## ‚úÖ Conclusion de l'Audit

### √âtat Actuel
Le syst√®me de facturation SmartQueue dispose d'une **base solide** avec:
- ‚úÖ Mod√®les de donn√©es robustes
- ‚úÖ API RESTful fonctionnelle
- ‚úÖ Interface admin moderne
- ‚úÖ Support Mobile Money complet

### Points √† Am√©liorer
Les **6 fonctionnalit√©s avanc√©es** audit√©es sont **majoritairement absentes** (66% non impl√©ment√©es).

### Recommandation
Prioriser **Phase 1** (Relances Auto + Codes Promo) pour:
1. Automatiser la gestion des impay√©s
2. R√©duire la charge op√©rationnelle
3. Activer le marketing

**Effort**: 5-8 jours
**ROI**: Imm√©diat et mesurable

---

*Audit r√©alis√© le 14 octobre 2025*
*Syst√®me audit√©: SmartQueue v1.0 - Backend Django + Frontend Next.js*
